import{s as Q,t as B}from"./SimpleGeometryCursor-e3941f41.js";import{j as F,P as j,a as q,m as k,e as p,Q as G,r as H,R as J}from"./Transformation2D-6dd5ab6c.js";import{e as b,n as D,w as K,c as W,ay as Z,aw as X,k as ee}from"./ProjectionTransformation-c10c6bf7.js";import{u as te}from"./Centroid-DZi-eb9F-fabfe8d8.js";import{m as A}from"./OperatorProximity-48ddc507.js";import{toPoint as U,getSpatialReference as V,fromGeometry as O}from"./apiConverter-9bb9913a.js";class ne{getOperatorType(){return 10203}accelerateGeometry(e,s,o){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,s){return new I(e,s)}execute(e,s){return new I(null,s).labelPoint(e)}}class I extends B{progress_(){}tock(){return!0}getRank(){return 1}constructor(e,s){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=s,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(F(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(e===null&&j("null pointer is not allowed"),e.getGeometryType()===q.enumPoint)return e;if(e.isEmpty())return new b({vd:e.getDescription()});switch(e.getGeometryType()){case q.enumPolygon:return this.labelPointPolygon(e);case q.enumPolyline:return this.labelPointPolyline(e);case q.enumMultiPoint:return this.labelPointMultiPoint(e);case q.enumEnvelope:return this.labelPointEnvelope(e);default:j("geometry is not supported")}}labelPointPolygon(e){const s=new D;e.queryEnvelope(s);const o=K(null,s,!0).total();let l=null,r=e;if(e.hasNonLinearSegments()){const t=new W({copy:e}),m=Z(t,.25*o,o);k(m!==e),l=m,r=l}let u=0,x=0;for(let t=0,m=r.getPathCount();t<m;++t){const M=Math.abs(r.calculateRingArea2D(t));M>x&&(x=M,u=t)}const a=new p;if(Math.abs(x)<=2*o*o?a.setNAN():a.assign(te(r,u)),Number.isNaN(a.x)){const t=new D;return r.queryPathEnvelope(u,t),new b({pt:t.getCenter()})}if(r.getPointCount()<4)return new b({x:a.x,y:a.y});const h=p.getNAN(),n=[h.clone(),h.clone(),h.clone(),h.clone()],N=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],g=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let E=!1,P=new A().getNearestCoordinate(r,a,!0,!1);if(P.m_distance===0&&(E=!0,n[0]=a,P=new A().getNearestCoordinate(r,a,!1,!1),P.m_distance>.25*s.minDimension()*1.66666666))return new b({x:a.x,y:a.y});N[0]=P.m_distance,g[0]=0;const d=new p;let c=!1,i=.25,y=-1;const _=new D;r.queryPathEnvelope(u,_);do{let t=Number.NaN;if(n[1]=this.calculateParacentroid_(r,G(_.xmin,_.xmax,i),o),n[1].isNAN()||(P=new A().getNearestCoordinate(r,n[1],!1,!1),t=P.m_distance),t>o&&X(r,n[1],o)===1)c=!0,N[1]=t,g[1]=p.sqrDistance(n[1],a);else if(t>y&&(y=t,d.setCoordsPoint2D(n[1])),i-=.01,i<.1){if(!(y>=0))break;c=!0,N[1]=y,n[1]=d,g[1]=p.sqrDistance(n[1],a)}}while(!c);c=!1,i=.5,y=-1;let T=.01,R=1;do{let t=Number.NaN;if(n[2]=this.calculateParacentroid_(r,G(_.xmin,_.xmax,i),o),n[2].isNAN()||(P=new A().getNearestCoordinate(r,n[2],!1,!1),t=P.m_distance),t>o&&X(r,n[2],o)===1)c=!0,N[2]=t,g[2]=p.sqrDistance(n[2],a);else if(t>y&&(y=t,d.setCoordsPoint2D(n[2])),i=.5+T*R,T+=.01,R*=-1,i<.3||i>.7){if(!(y>=0))break;c=!0,N[2]=y,n[2]=d,g[2]=p.sqrDistance(n[2],a)}}while(!c);c=!1,i=.75,y=-1;do{let t=Number.NaN;if(n[3]=this.calculateParacentroid_(r,G(_.xmin,_.xmax,i),o),n[3].isNAN()||(P=new A().getNearestCoordinate(r,n[3],!1,!1),t=P.m_distance),t>o&&X(r,n[3],o)===1)c=!0,N[3]=t,g[3]=p.sqrDistance(n[3],a);else if(t>y&&(y=t,d.setCoordsPoint2D(n[3])),i+=.01,i>.9){if(!(y>=0))break;c=!0,N[3]=y,n[3]=d,g[3]=p.sqrDistance(n[3],a)}}while(!c);const w=[0,1,2,3],v=E?0:1;for(let t=v;t<4;t++)for(let m=v;m<3;m++){const M=g[m],$=g[m+1];if(H(M,$)>0){const z=w[m];w[m]=w[m+1],w[m+1]=z,g[m]=$,g[m+1]=M}}let S=v,Y=0,C=0;for(let t=v;t<4;t++){switch(t){case 0:C=2*N[w[t]];break;case 1:C=1.66666666*N[w[t]];break;case 2:C=1.33333333*N[w[t]];break;case 3:C=N[w[t]]}C>Y&&(Y=C,S=w[t])}return k(!n[S].isNAN()),new b({x:n[S].x,y:n[S].y})}labelPointPolyline(e){const s=new p;if(e.getPointCount()>2*e.getPathCount()){let o=-1,l=-Number.MAX_VALUE;for(let a=0,h=e.getPathCount();a<h;a++)if(e.getPathSize(a)>2){const n=e.calculatePathLength2D(a);n>l&&(l=n,o=a)}const r=e.getPathStart(o),u=e.getPathEnd(o),x=Math.trunc((r+u)/2);s.assign(e.getXY(x))}else{let o=-Number.MAX_VALUE;const l=e.querySegmentIterator();for(;l.nextPath();)if(l.hasNextSegment()){const r=l.nextSegment(),u=r.calculateLength2D();u>o&&(o=u,s.assign(r.getCoord2D(r.lengthToT(.5*u))))}}return new b({x:s.x,y:s.y})}labelPointMultiPoint(e){const s=new D;e.queryEnvelope(s);const o=s.getCenter(),l=new A().getNearestCoordinate(e,o,!1,!1).m_coordinate;return new b({x:l.x,y:l.y})}labelPointEnvelope(e){const s=e.getCenterXY();return new b({x:s.x,y:s.y})}calculateParacentroid_(e,s,o){const l=new D;e.queryEnvelope(l);const r=new p(s,0);let u=Number.MAX_VALUE,x=Number.MAX_VALUE,a=!1,h=!1;const n=new ee;n.setStartXYCoords(r.x,l.ymin-1),n.setEndXYCoords(r.x,l.ymax+1);const N=new D,g=new p,E=new p,P=J(p,2),d=e.querySegmentIterator();for(;d.nextPath();)for(;d.hasNextSegment();){const c=d.nextSegment();if(c.queryEnvelope(N),k(c.isMonotoneQuickAndDirty()),g.setCoordsPoint2D(n.getStartXY()),E.setCoordsPoint2D(n.getEndXY()),N.clipLine(g,E)===0||n.intersect(c,P,null,null,o)!==1)continue;const i=P[0].y;u>x?i<u&&(u=i,a=!0):i<x&&(x=i,h=!0)}return a&&h?r.y=(u+x)/2:r.setNAN(),r}}const L=new ne;function re(f){return L.execute(f,null)}function oe(f){const e=L.executeMany(new Q(f),null);return Array.from(e)}function se(){return L.supportsCurves()}function ae(f){return U(re(O(f)),V(f))}function ie(f){const e=f.map(O),s=V(f);return oe(e).map(o=>U(o,s))}const le=se(),pe=Object.freeze(Object.defineProperty({__proto__:null,execute:ae,executeMany:ie,supportsCurves:le},Symbol.toStringTag,{value:"Module"}));export{pe as c,le as n,ae as p,ie as u};
